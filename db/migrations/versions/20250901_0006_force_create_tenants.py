"""force create/patch tenants table in target schema and ensure users FK

Revision ID: 20250901_0006
Revises: 20250901_0005
Create Date: 2025-08-30 13:00:00

This migration is intentionally defensive:
- Creates schema-qualified app.tenants (or <schema>.tenants) if missing.
- Adds missing columns with IF NOT EXISTS.
- Backfills key/name if null/empty, then enforces uniqueness via index.
- Ensures users(tenant_id) -> tenants(id) FK exists.
"""

from __future__ import annotations

import os
from alembic import op
import sqlalchemy as sa
from sqlalchemy import text

# Revision identifiers, used by Alembic.
revision: str = "20250901_0006"
down_revision: str | None = "20250901_0005"
branch_labels = None
depends_on = None


def _schema() -> str:
    return (
        os.getenv("ALEMBIC_SCHEMA")
        or os.getenv("POSTGRES_SCHEMA")
        or os.getenv("DB_SCHEMA")
        or "app"
    ).strip() or "app"


def upgrade() -> None:
    schema = _schema()
    conn = op.get_bind()

    # 1) Create tenants table if it doesn't exist (schema-qualified).
    # Use IDENTITY for portability; existing tables are left untouched.
    conn.execute(
        text(
            f'''
            CREATE TABLE IF NOT EXISTS "{schema}"."tenants" (
                id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                key VARCHAR(64),
                name VARCHAR(255),
                created_at TIMESTAMPTZ DEFAULT now(),
                updated_at TIMESTAMPTZ DEFAULT now()
            );
            '''
        )
    )

    # 2) Ensure columns exist (nullable first) to avoid NOT NULL violations on existing rows.
    conn.execute(text(f'ALTER TABLE "{schema}"."tenants" ADD COLUMN IF NOT EXISTS key VARCHAR(64);'))
    conn.execute(text(f'ALTER TABLE "{schema}"."tenants" ADD COLUMN IF NOT EXISTS name VARCHAR(255);'))
    conn.execute(text(f'ALTER TABLE "{schema}"."tenants" ADD COLUMN IF NOT EXISTS created_at TIMESTAMPTZ DEFAULT now();'))
    conn.execute(text(f'ALTER TABLE "{schema}"."tenants" ADD COLUMN IF NOT EXISTS updated_at TIMESTAMPTZ DEFAULT now();'))

    # 3) Backfill any missing/empty key or name to deterministic values.
    conn.execute(
        text(
            f'''
            UPDATE "{schema}"."tenants"
            SET key = 'tenant-' || id
            WHERE key IS NULL OR key = '';
            '''
        )
    )
    conn.execute(
        text(
            f'''
            UPDATE "{schema}"."tenants"
            SET name = COALESCE(name, 'Tenant ' || id)
            WHERE name IS NULL OR name = '';
            '''
        )
    )
    conn.execute(
        text(
            f'''
            UPDATE "{schema}"."tenants"
            SET created_at = COALESCE(created_at, now()),
                updated_at = COALESCE(updated_at, now());
            '''
        )
    )

    # 4) Enforce NOT NULLs (best-effort).
    try:
        conn.execute(text(f'ALTER TABLE "{schema}"."tenants" ALTER COLUMN key SET NOT NULL;'))
    except Exception:
        pass
    try:
        conn.execute(text(f'ALTER TABLE "{schema}"."tenants" ALTER COLUMN name SET NOT NULL;'))
    except Exception:
        pass
    try:
        conn.execute(text(f'ALTER TABLE "{schema}"."tenants" ALTER COLUMN created_at SET NOT NULL;'))
    except Exception:
        pass
    try:
        conn.execute(text(f'ALTER TABLE "{schema}"."tenants" ALTER COLUMN updated_at SET NOT NULL;'))
    except Exception:
        pass

    # 5) Ensure unique index on key (use an index name stable across schema).
    # Postgres allows IF NOT EXISTS for indexes since v9.5.
    conn.execute(
        text(
            f'CREATE UNIQUE INDEX IF NOT EXISTS "ix_tenants_key" ON "{schema}"."tenants"(key);'
        )
    )

    # 6) Ensure users(tenant_id) -> tenants(id) FK exists (if both table/column exist).
    insp = sa.inspect(conn)
    users_has_table = "users" in insp.get_table_names(schema=schema)
    if users_has_table:
        cols = {c["name"] for c in insp.get_columns("users", schema=schema)}
        if "tenant_id" in cols:
            try:
                existing_fks = {fk.get("name") for fk in insp.get_foreign_keys("users", schema=schema)}
            except Exception:
                existing_fks = set()

            if "fk_users_tenant_id_tenants" not in existing_fks:
                try:
                    op.create_foreign_key(
                        "fk_users_tenant_id_tenants",
                        "users",
                        "tenants",
                        ["tenant_id"],
                        ["id"],
                        source_schema=schema,
                        referent_schema=schema,
                        ondelete="SET NULL",
                    )
                except Exception:
                    pass


def downgrade() -> None:
    # Conservative: drop FK only; do not drop tenants table or its index.
    schema = _schema()
    try:
        op.drop_constraint("fk_users_tenant_id_tenants", "users", type_="foreignkey", schema=schema)
    except Exception:
        pass
